# Многопоточность без страха

Обеспечение безопасности памяти - это не единственная задача, с которой справляется
Rust: быть языком, который лучше других оснащен для многопоточного и параллельного
программирования, всегда был ещё одной сильной стороной Rust. *Многопоточное программирование*,
где различные части программы выполняется независимо и *параллельное программирование*,
где разные части программы выполняются в одно и то же время, становятся все более
важными поскольку все больше компьютеров используют несколько процессоров для того,
чтобы наши программы могли воспользоваться преимуществами системы. Исторически,
программирование в этих контекстах было трудным и подвержено множеству ошибок.
Rust надеется это изменить.

Можно подумать, что проблема защиты памяти и предотвращения проблем многопоточности
- это две разные проблемы и должны решаться разными способами. Однако мы обнаружили,
что владение и система типов являются мощным набором инструменты, которые помогают
справляться с проблемами безопасности памяти *и* многопоточности!
При использовании прав владения и проверки типов многие ошибки многопоточности
*ошибки компиляции* в Rust, а не ошибки времени выполнения. Мы прозвали этот аспект
от Rust *многопоточность без страха*. Это значит, что Rust не только позволяет
вам иметь уверенность в отсутствии побочных ошибок, но также позволяет вам
провести рефакторинг этого типа кода легко, не беспокоясь о появлении новых ошибок.

> Обратите внимание на слоган *многопоточность без страха*. Мы говорим сейчас о
> проблемах *многопоточности* (для краткости) - полная версия *многопоточность и параллелизм*.

Многие языки убеждены в надёжности решений, которые они предлагают вам. Это очень
разумная стратегия, особенно для языков более высокого уровня. Языки более низкого
уровня не имеют такой роскоши. Rust дает нам множество инструментов для моделирования
различными способами.

Тема этой главы:
* Создание потока для одновременного выполнения кода
* Отправка сообщений* параллельно и использование каналов для отправки сообщений
  между потоками.
 *Разделение состояния* многопоточности. Множество потоков имеют доступ к какой-то
  части данных.
* Потокобезопасные типажи `Sync` и `Send`
