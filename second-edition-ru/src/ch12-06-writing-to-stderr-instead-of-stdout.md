## Вывод сообщений о ошибках в стандартный поток для ошибок вместо стандартного потока
консольного приложения

Во всех предыдущих примерах книги вы выводили все сообщения в стандартный поток
терминала с помощью макроса `println!`. Обычно терминалы предоставляют два вида
вывода данных: *стандартный* для общений информации и *для ошибок*. Такая особенность
позволяет, например, писать настройки текущего состояния программы в файл, а сообщения
об ошибках на экран.

Для вывода сообщений в поток ошибок нам понадобиться специальный подход, которым
мы опишем далее.

### Проверка где записываются сообщения об ошибках

Для начала рассмотрим как сообщения об ошибках выводятся в текущей версии программы.
Далее перенаправил поток вывода сообщений в файл. Удобным способом перенаправления
потока данных в консольном приложение является символ  `>`. Перенаправим поток
вывода в файл *output.txt*. Проверим как это работает:

```text
$ cargo run > output.txt
```

Теперь посмотрим на содержание файла *output.txt*:

```text
Problem parsing arguments: not enough arguments
```

Мы видим, что сообщение об ошибке было напечатано в стандартный поток вывода.
Было бы более удобно, если бы сообщения об ошибках печатались бы в стандартный
поток ошибок. Чтобы только сообщения о успешном выполнении программы печатались в
стандартный поток.

### Печать ошибок в поток ошибок

Рассмотрим способ перенаправления поток с помощью кода программы (12-24).
Так как после проведённого рефакторинга все сообщения сосредоточены в одной функции
`main` нам будет удобно сделать необходимые изменения. В стандартную библиотеку
входит макрос `eprintln!`, который печатает сообщения в поток ошибок. Пожалуйста,
познакомьтесь с обновлённым кодом функции `main`:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {}", e);

        process::exit(1);
    }
}
```

<span class="caption">Код 12-24: Вывод сообщений об ошибках в поток ошибок с помощью
макроса `eprintln!`</span>

Пожалуйста, проверьте работу обновлённой версии программы:

```text
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

Вы также видите сообщения об ошибке на экране, но в файл `output.txt` информация
об ошибке не была записана.

Если же вы напишите всё правильно и программа выполниться без ошибок, файл будет
содержать найденный строки:

```text
$ cargo run to poem.txt > output.txt
```

Содержание файла `output.txt` после работы программы:

<span class="filename">Filename: output.txt</span>

```text
Are you nobody, too?
How dreary to be somebody!
```

## Итоги

В этой главе вы использовали наши накопленный опыт и научились работать с файлами.
Мы создали работающее (правильность работы подтверждена модульными тестами)
консольное приложение, которое успешно работает с параметрами командной стоки,
системными переменными, файлами, использует макрос `eprintln!` для вывода ошибок.

Далее мы рассмотрим уже знакомые вам концепции языка Rust, о которых мы ранее уже
упоминали и использовали в некоторых демонстрационных примерах. Думаю, что у вас
уже есть о них общее представление. Пора углубить ваши знания. Итак, замыкания и
итераторы к вашим услугам!
