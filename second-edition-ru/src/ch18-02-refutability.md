## Когда шаблон может не сработать

Шаблоны делятся на два вида - действительные всегда или действительные частично.
Например операторы `if let`и `while let` требуют только действительные шаблоны.

В общем случае вам нет необходимости беспокоится об этих особенностях.
Но всё же бывают случаи, когда из-за этого могут возникнуть ошибки. Например, в
примере `let x = 5;` шаблон является всегда действительным. Если же в качестве
типа данных используется перечисление `Some<T>`, может возникнуть ошибка.:

```rust,ignore
let Some(x) = some_option_value;
```

<span class="caption">Listing 18-7: попытка присвоить действительный частично
шаблон `let`</span>

Если `some_option_value` = `None`, эта это значение не будет соответствовать шаблону
`Some(x)`. Шаблон `Some(x)` не покрывает всех возможных значений перечисления.
Поэтому компилятор сообщит об ошибке:

```text
error[E0005]: refutable pattern in local binding: `None` not covered
 --> <anon>:3:5
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
```

Т.к. мы не можем обеспечить подобной конструкции хранить все возможные значения,
она не считается правильной.

Решить проблему компиляции выражение `if let`. Если шаблон не будет действительный,
код внутри не сработает. Пример показан в коде  18-8:

```rust
# let some_option_value: Option<i32> = None;
if let Some(x) = some_option_value {
    println!("{}", x);
}
```

<span class="caption">код 18-8: использование `if let` и блока с невсеохватывающим
шаблоном (вместо `let`)</span>

Если же в конструкцию `if let` вы внесёте всеохватывающих шаблон или константное
значение, то компилятор также сообщит об ошибке в коде 18-9:

```rust,ignore
if let x = 5 {
    println!("{}", x);
};
```

<span class="caption">код 18-9: попытка использования всеохватывающего шаблона в
в конструкции `if let`</span>

Сообщение об ошибке:

```text
error[E0162]: irrefutable if-let pattern
 --> <anon>:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
```

В конструкции `match` в последнем условии (или рукаве) можно использовать шаблон,
который охватывает все остальные варианты.

В этой секции мы рассказали вам о тонкостях работы шаблонов в Rust. Далее, мы
рассмотрим более подробно синтаксис.
